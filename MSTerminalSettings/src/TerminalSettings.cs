// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using WindowsTerminal;
//
//    var terminalSettings = TerminalSettings.FromJson(jsonString);

namespace WindowsTerminal
{
    using System; 
    using System.ComponentModel;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// Properties that affect the entire window, regardless of the profile settings.
    /// </summary>
    public partial class TerminalSettings
    {
        /// <summary>
        /// When set to true, tabs are always displayed. When set to false and showTabsInTitlebar is
        /// set to false, tabs only appear after opening a new tab.
        /// </summary>
        [JsonProperty("alwaysShowTabs", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AlwaysShowTabs { get; set; }

        /// <summary>
        /// When set to `true` closing a window with multiple tabs open WILL require confirmation.
        /// When set to `false` closing a window with multiple tabs open WILL NOT require
        /// confirmation.
        /// </summary>
        [JsonProperty("confirmCloseAllTabs", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ConfirmCloseAllTabs { get; set; }

        /// <summary>
        /// When set to `true`, the color and font formatting of selected text is also copied to your
        /// clipboard. When set to `false`, only plain text is copied to your clipboard.
        /// </summary>
        [JsonProperty("copyFormatting", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CopyFormatting { get; set; }

        /// <summary>
        /// When set to true, a selection is immediately copied to your clipboard upon creation. When
        /// set to false, the selection persists and awaits further action.
        /// </summary>
        [JsonProperty("copyOnSelect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CopyOnSelect { get; set; }

        /// <summary>
        /// Sets the default profile. Opens by clicking the '+' icon or typing the key binding
        /// assigned to 'newTab'. The guid of the desired default profile is used as the value.
        /// </summary>
        [JsonProperty("defaultProfile")]
        [DefaultValue("")]         public string DefaultProfile { get; set; }

        /// <summary>
        /// Disables all the dynamic profile generators in this list, preventing them from adding
        /// their profiles to the list of profiles on startup.
        /// </summary>
        [JsonProperty("disabledProfileSources", NullValueHandling = NullValueHandling.Ignore)]
        public List<DynamicProfileSource> DisabledProfileSources { get; set; }

        /// <summary>
        /// The number of columns displayed in the window upon first load.
        /// </summary>
        [JsonProperty("initialCols", NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialCols { get; set; }

        /// <summary>
        /// The position of the top left corner of the window upon first load. On a system with
        /// multiple displays, these coordinates are relative to the top left of the primary display.
        /// If launchMode is set to maximized, the window will be maximized on the monitor specified
        /// by those coordinates.
        /// </summary>
        [JsonProperty("initialPosition", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string InitialPosition { get; set; }

        /// <summary>
        /// The number of rows displayed in the window upon first load.
        /// </summary>
        [JsonProperty("initialRows", NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialRows { get; set; }

        /// <summary>
        /// Properties are specific to each custom key binding.
        /// </summary>
        [JsonProperty("keybindings", NullValueHandling = NullValueHandling.Ignore)]
        public List<Keybinding> Keybindings { get; set; }

        /// <summary>
        /// Defines whether the Terminal will launch as maximized or not.
        /// </summary>
        [JsonProperty("launchMode", NullValueHandling = NullValueHandling.Ignore)]
        public LaunchMode? LaunchMode { get; set; }

        /// <summary>
        /// The number of rows to scroll at a time with the mouse wheel. This will override the
        /// system setting if the value is not zero or 'system'.
        /// </summary>
        [JsonProperty("rowsToScroll", NullValueHandling = NullValueHandling.Ignore)]
        public RowsToScroll? RowsToScroll { get; set; }

        /// <summary>
        /// When set to true, the tabs are moved into the titlebar and the titlebar disappears. When
        /// set to false, the titlebar sits above the tabs.
        /// </summary>
        [JsonProperty("showTabsInTitlebar", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowTabsInTitlebar { get; set; }

        /// <summary>
        /// When set to true, titlebar displays the title of the selected tab. When set to false,
        /// titlebar displays 'Windows Terminal'.
        /// </summary>
        [JsonProperty("showTerminalTitleInTitlebar", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowTerminalTitleInTitlebar { get; set; }

        /// <summary>
        /// When set to true, the window will snap to the nearest character boundary on resize. When
        /// false, the window will resize 'smoothly'
        /// </summary>
        [JsonProperty("snapToGridOnResize", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapToGridOnResize { get; set; }

        /// <summary>
        /// Sets the width of the tabs.
        /// </summary>
        [JsonProperty("tabWidthMode", NullValueHandling = NullValueHandling.Ignore)]
        public TabWidthMode? TabWidthMode { get; set; }

        /// <summary>
        /// Sets the theme of the application.
        /// </summary>
        [JsonProperty("theme", NullValueHandling = NullValueHandling.Ignore)]
        public Theme? Theme { get; set; }

        /// <summary>
        /// Determines the delimiters used in a double click selection.
        /// </summary>
        [JsonProperty("wordDelimiters", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string WordDelimiters { get; set; }

        [JsonProperty("profiles")]
        public ProfilesObject Profiles { get; set; }

        [JsonProperty("schemes")]
        public List<SchemeList> Schemes { get; set; }
    }

    public partial class Keybinding
    {
        /// <summary>
        /// The action executed when the associated key bindings are pressed.
        /// </summary>
        [JsonProperty("command")]
        public Command Command { get; set; }

        /// <summary>
        /// Defines the key combinations used to call the command.
        /// </summary>
        [JsonProperty("keys")]
        public Keys Keys { get; set; }
    }

    /// <summary>
    /// Arguments corresponding to an Adjust Font Size Action
    ///
    /// Arguments corresponding to a Copy Text Action
    ///
    /// Arguments corresponding to a New Tab Action
    ///
    /// Arguments corresponding to a Switch To Tab Action
    ///
    /// Arguments corresponding to a Move Focus Action
    ///
    /// Arguments corresponding to a Resize Pane Action
    ///
    /// Arguments corresponding to a Split Pane Action
    /// </summary>
    public partial class Action
    {
        /// <summary>
        /// How much to change the current font point size
        /// </summary>
        [JsonProperty("delta", NullValueHandling = NullValueHandling.Ignore)]
        public long? Delta { get; set; }

        /// <summary>
        /// The action to execute
        /// </summary>
        [JsonProperty("action")]
        public ActionEnum ActionAction { get; set; }

        /// <summary>
        /// If true, newlines are removed and whitespace is maintained. If false, whitespace is
        /// removed and newlines are maintained.
        /// </summary>
        [JsonProperty("singleLine", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SingleLine { get; set; }

        /// <summary>
        /// A commandline to use instead of the profile's
        /// </summary>
        [JsonProperty("commandline", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Commandline { get; set; }

        /// <summary>
        /// The index of the profile in the new tab dropdown to open
        ///
        /// Which tab to switch to, with the first being 0
        /// </summary>
        [JsonProperty("index", NullValueHandling = NullValueHandling.Ignore)]
        public long? Index { get; set; }

        /// <summary>
        /// Either the GUID or name of a profile to use, instead of launching the default
        /// </summary>
        [JsonProperty("profile", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Profile { get; set; }

        /// <summary>
        /// A startingDirectory to use instead of the profile's
        /// </summary>
        [JsonProperty("startingDirectory", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string StartingDirectory { get; set; }

        /// <summary>
        /// An initial tabTitle to use instead of the profile's
        /// </summary>
        [JsonProperty("tabTitle", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string TabTitle { get; set; }

        /// <summary>
        /// The direction to move focus in, between panes
        ///
        /// The direction to move the pane separator in
        /// </summary>
        [JsonProperty("direction", NullValueHandling = NullValueHandling.Ignore)]
        public Direction? Direction { get; set; }

        /// <summary>
        /// The orientation to split the pane in, either vertical (think [|]), horizontal (think
        /// [-]), or auto (splits pane based on remaining space)
        /// </summary>
        [JsonProperty("split", NullValueHandling = NullValueHandling.Ignore)]
        public SplitState? Split { get; set; }

        /// <summary>
        /// Control how the pane splits. Only accepts `duplicate` which will duplicate the focused
        /// pane's profile into a new pane.
        /// </summary>
        [JsonProperty("splitMode")]
        public object SplitMode { get; set; }
    }

    /// <summary>
    /// A list of profiles and default settings that apply to all of them
    /// </summary>
    public partial class ProfilesObject
    {
        /// <summary>
        /// The default settings that apply to every profile.
        /// </summary>
        [JsonProperty("defaults", NullValueHandling = NullValueHandling.Ignore)]
        public Profile Defaults { get; set; }

        [JsonProperty("list", NullValueHandling = NullValueHandling.Ignore)]
        public List<ProfileList> List { get; set; }
    }

    /// <summary>
    /// The default settings that apply to every profile.
    ///
    /// Properties specific to a unique profile.
    /// </summary>
    public partial class Profile
    {
        /// <summary>
        /// When useAcrylic is set to true, it sets the transparency of the window for the profile.
        /// Accepts floating point values from 0-1 (default 0.5).
        /// </summary>
        [JsonProperty("acrylicOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public decimal? AcrylicOpacity { get; set; }

        /// <summary>
        /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
        /// "cleartype" and "aliased". Note that changing this setting will require starting a new
        /// terminal instance.
        /// </summary>
        [JsonProperty("antialiasingMode", NullValueHandling = NullValueHandling.Ignore)]
        public AntialiasingMode? AntialiasingMode { get; set; }

        /// <summary>
        /// Sets the background color of the profile. Overrides background set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Background { get; set; }

        /// <summary>
        /// Sets the file location of the Image to draw over the window background.
        /// </summary>
        [JsonProperty("backgroundImage")]
        [DefaultValue("")]         public string BackgroundImage { get; set; }

        /// <summary>
        /// Sets how the background image aligns to the boundaries of the window. Possible values:
        /// "center", "left", "top", "right", "bottom", "topLeft", "topRight", "bottomLeft",
        /// "bottomRight"
        /// </summary>
        [JsonProperty("backgroundImageAlignment", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageAlignment? BackgroundImageAlignment { get; set; }

        /// <summary>
        /// Sets the transparency of the background image. Accepts floating point values from 0-1.
        /// </summary>
        [JsonProperty("backgroundImageOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public decimal? BackgroundImageOpacity { get; set; }

        /// <summary>
        /// Sets how the background image is resized to fill the window.
        /// </summary>
        [JsonProperty("backgroundImageStretchMode", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageStretchMode? BackgroundImageStretchMode { get; set; }

        /// <summary>
        /// Sets how the profile reacts to termination or failure to launch. Possible values:
        /// "graceful" (close when exit is typed or the process exits normally), "always" (always
        /// close) and "never" (never close). true and false are accepted as synonyms for "graceful"
        /// and "never" respectively.
        /// </summary>
        [JsonProperty("closeOnExit", NullValueHandling = NullValueHandling.Ignore)]
        public CloseOnExitUnion? CloseOnExit { get; set; }

        /// <summary>
        /// Name of the terminal color scheme to use. Color schemes are defined under "schemes".
        /// </summary>
        [JsonProperty("colorScheme", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string ColorScheme { get; set; }

        /// <summary>
        /// Array of colors used in the profile if colorscheme is not set. Colors use hex color
        /// format: "#rrggbb". Ordering is as follows: [black, red, green, yellow, blue, magenta,
        /// cyan, white, bright black, bright red, bright green, bright yellow, bright blue, bright
        /// magenta, bright cyan, bright white]
        /// </summary>
        [JsonProperty("colorTable", NullValueHandling = NullValueHandling.Ignore)]
        public List<ColorTable> ColorTable { get; set; }

        /// <summary>
        /// Executable used in the profile.
        /// </summary>
        [JsonProperty("commandline", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Commandline { get; set; }

        /// <summary>
        /// A GUID reference to a connection type. Currently undocumented as of 0.3, this is used for
        /// Azure Cloud Shell
        /// </summary>
        [JsonProperty("connectionType", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string ConnectionType { get; set; }

        /// <summary>
        /// Sets the cursor color of the profile. Overrides cursor color set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("cursorColor", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string CursorColor { get; set; }

        /// <summary>
        /// Sets the percentage height of the cursor starting from the bottom. Only works when
        /// cursorShape is set to "vintage". Accepts values from 25-100.
        /// </summary>
        [JsonProperty("cursorHeight")]
        public long? CursorHeight { get; set; }

        /// <summary>
        /// Sets the cursor shape for the profile. Possible values: "vintage" ( ??? ), "bar" ( ???,
        /// default ), "underscore" ( ??? ), "filledBox" ( ??? ), "emptyBox" ( ??? )
        /// </summary>
        [JsonProperty("cursorShape", NullValueHandling = NullValueHandling.Ignore)]
        public CursorShape? CursorShape { get; set; }

        /// <summary>
        /// When set to true, enable retro terminal effects. This is an experimental feature, and its
        /// continued existence is not guaranteed.
        /// </summary>
        [JsonProperty("experimental.retroTerminalEffect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRetroTerminalEffect { get; set; }

        /// <summary>
        /// Name of the font face used in the profile.
        /// </summary>
        [JsonProperty("fontFace", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string FontFace { get; set; }

        /// <summary>
        /// Sets the font size.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public long? FontSize { get; set; }

        /// <summary>
        /// Sets the foreground color of the profile. Overrides foreground set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("foreground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Foreground { get; set; }

        /// <summary>
        /// Unique identifier of the profile. Written in registry format:
        /// "{00000000-0000-0000-0000-000000000000}".
        /// </summary>
        [JsonProperty("guid", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Guid { get; set; }

        /// <summary>
        /// If set to true, the profile will not appear in the list of profiles. This can be used to
        /// hide default profiles and dynamically generated profiles, while leaving them in your
        /// settings file.
        /// </summary>
        [JsonProperty("hidden", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        /// <summary>
        /// The number of lines above the ones displayed in the window you can scroll back to.
        /// </summary>
        [JsonProperty("historySize", NullValueHandling = NullValueHandling.Ignore)]
        public long? HistorySize { get; set; }

        /// <summary>
        /// Image file location of the icon used in the profile. Displays within the tab and the
        /// dropdown menu.
        /// </summary>
        [JsonProperty("icon")]
        [DefaultValue("")]         public string Icon { get; set; }

        /// <summary>
        /// Name of the profile. Displays in the dropdown menu.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        [DefaultValue("")]         public string Name { get; set; }

        /// <summary>
        /// Sets the padding around the text within the window. Can have three different formats: "#"
        /// sets the same padding for all sides, "#, #" sets the same padding for left-right and
        /// top-bottom, and "#, #, #, #" sets the padding individually for left, top, right, and
        /// bottom.
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Padding { get; set; }

        /// <summary>
        /// Defines the visibility of the scrollbar.
        /// </summary>
        [JsonProperty("scrollbarState", NullValueHandling = NullValueHandling.Ignore)]
        public ScrollbarState? ScrollbarState { get; set; }

        /// <summary>
        /// Sets the selection background color of the profile. Overrides selection background set in
        /// color scheme if colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("selectionBackground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string SelectionBackground { get; set; }

        /// <summary>
        /// When set to true, the window will scroll to the command input line when typing. When set
        /// to false, the window will not scroll when you start typing.
        /// </summary>
        [JsonProperty("snapOnInput", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapOnInput { get; set; }

        /// <summary>
        /// Stores the name of the profile generator that originated this profile.
        /// </summary>
        [JsonProperty("source")]
        [DefaultValue("")]         public string Source { get; set; }

        /// <summary>
        /// The directory the shell starts in when it is loaded.
        /// </summary>
        [JsonProperty("startingDirectory", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string StartingDirectory { get; set; }

        /// <summary>
        /// When set to true, tabTitle overrides the default title of the tab and any title change
        /// messages from the application will be suppressed. When set to false, tabTitle behaves as
        /// normal.
        /// </summary>
        [JsonProperty("suppressApplicationTitle", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressApplicationTitle { get; set; }

        /// <summary>
        /// If set, will replace the name as the title to pass to the shell on startup. Some shells
        /// (like bash) may choose to ignore this initial value, while others (cmd, powershell) may
        /// use this value over the lifetime of the application.
        /// </summary>
        [JsonProperty("tabTitle")]
        [DefaultValue("")]         public string TabTitle { get; set; }

        /// <summary>
        /// When set to true, the window will have an acrylic background. When set to false, the
        /// window will have a plain, untextured background.
        /// </summary>
        [JsonProperty("useAcrylic", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseAcrylic { get; set; }
    }

    public partial class ColorTable
    {
        /// <summary>
        /// Sets the background color of the color table.
        /// </summary>
        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Background { get; set; }

        /// <summary>
        /// Sets the color used as ANSI black.
        /// </summary>
        [JsonProperty("black", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Black { get; set; }

        /// <summary>
        /// Sets the color used as ANSI blue.
        /// </summary>
        [JsonProperty("blue", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Blue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright black.
        /// </summary>
        [JsonProperty("brightBlack", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightBlack { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright blue.
        /// </summary>
        [JsonProperty("brightBlue", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightBlue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright cyan.
        /// </summary>
        [JsonProperty("brightCyan", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightCyan { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright green.
        /// </summary>
        [JsonProperty("brightGreen", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightGreen { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright purple.
        /// </summary>
        [JsonProperty("brightPurple", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightPurple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright red.
        /// </summary>
        [JsonProperty("brightRed", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightRed { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright white.
        /// </summary>
        [JsonProperty("brightWhite", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightWhite { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright yellow.
        /// </summary>
        [JsonProperty("brightYellow", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightYellow { get; set; }

        /// <summary>
        /// Sets the color used as ANSI cyan.
        /// </summary>
        [JsonProperty("cyan", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Cyan { get; set; }

        /// <summary>
        /// Sets the foreground color of the color table.
        /// </summary>
        [JsonProperty("foreground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Foreground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI green.
        /// </summary>
        [JsonProperty("green", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Green { get; set; }

        /// <summary>
        /// Sets the color used as ANSI purple.
        /// </summary>
        [JsonProperty("purple", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Purple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI red.
        /// </summary>
        [JsonProperty("red", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Red { get; set; }

        /// <summary>
        /// Sets the color used as ANSI white.
        /// </summary>
        [JsonProperty("white", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string White { get; set; }

        /// <summary>
        /// Sets the color used as ANSI yellow.
        /// </summary>
        [JsonProperty("yellow", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Yellow { get; set; }
    }

    /// <summary>
    /// A list of profiles and the properties specific to each.
    ///
    /// The default settings that apply to every profile.
    ///
    /// Properties specific to a unique profile.
    /// </summary>
    public partial class ProfileList
    {
        /// <summary>
        /// Unique identifier of the profile. Written in registry format:
        /// "{00000000-0000-0000-0000-000000000000}".
        /// </summary>
        [JsonProperty("guid")]
        [DefaultValue("")]         public string Guid { get; set; }

        /// <summary>
        /// Name of the profile. Displays in the dropdown menu.
        /// </summary>
        [JsonProperty("name")]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        [DefaultValue("")]         public string Name { get; set; }

        /// <summary>
        /// When useAcrylic is set to true, it sets the transparency of the window for the profile.
        /// Accepts floating point values from 0-1 (default 0.5).
        /// </summary>
        [JsonProperty("acrylicOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public decimal? AcrylicOpacity { get; set; }

        /// <summary>
        /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
        /// "cleartype" and "aliased". Note that changing this setting will require starting a new
        /// terminal instance.
        /// </summary>
        [JsonProperty("antialiasingMode", NullValueHandling = NullValueHandling.Ignore)]
        public AntialiasingMode? AntialiasingMode { get; set; }

        /// <summary>
        /// Sets the background color of the profile. Overrides background set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Background { get; set; }

        /// <summary>
        /// Sets the file location of the Image to draw over the window background.
        /// </summary>
        [JsonProperty("backgroundImage")]
        [DefaultValue("")]         public string BackgroundImage { get; set; }

        /// <summary>
        /// Sets how the background image aligns to the boundaries of the window. Possible values:
        /// "center", "left", "top", "right", "bottom", "topLeft", "topRight", "bottomLeft",
        /// "bottomRight"
        /// </summary>
        [JsonProperty("backgroundImageAlignment", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageAlignment? BackgroundImageAlignment { get; set; }

        /// <summary>
        /// Sets the transparency of the background image. Accepts floating point values from 0-1.
        /// </summary>
        [JsonProperty("backgroundImageOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public decimal? BackgroundImageOpacity { get; set; }

        /// <summary>
        /// Sets how the background image is resized to fill the window.
        /// </summary>
        [JsonProperty("backgroundImageStretchMode", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageStretchMode? BackgroundImageStretchMode { get; set; }

        /// <summary>
        /// Sets how the profile reacts to termination or failure to launch. Possible values:
        /// "graceful" (close when exit is typed or the process exits normally), "always" (always
        /// close) and "never" (never close). true and false are accepted as synonyms for "graceful"
        /// and "never" respectively.
        /// </summary>
        [JsonProperty("closeOnExit", NullValueHandling = NullValueHandling.Ignore)]
        public CloseOnExitUnion? CloseOnExit { get; set; }

        /// <summary>
        /// Name of the terminal color scheme to use. Color schemes are defined under "schemes".
        /// </summary>
        [JsonProperty("colorScheme", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string ColorScheme { get; set; }

        /// <summary>
        /// Array of colors used in the profile if colorscheme is not set. Colors use hex color
        /// format: "#rrggbb". Ordering is as follows: [black, red, green, yellow, blue, magenta,
        /// cyan, white, bright black, bright red, bright green, bright yellow, bright blue, bright
        /// magenta, bright cyan, bright white]
        /// </summary>
        [JsonProperty("colorTable", NullValueHandling = NullValueHandling.Ignore)]
        public List<ColorTable> ColorTable { get; set; }

        /// <summary>
        /// Executable used in the profile.
        /// </summary>
        [JsonProperty("commandline", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Commandline { get; set; }

        /// <summary>
        /// A GUID reference to a connection type. Currently undocumented as of 0.3, this is used for
        /// Azure Cloud Shell
        /// </summary>
        [JsonProperty("connectionType", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string ConnectionType { get; set; }

        /// <summary>
        /// Sets the cursor color of the profile. Overrides cursor color set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("cursorColor", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string CursorColor { get; set; }

        /// <summary>
        /// Sets the percentage height of the cursor starting from the bottom. Only works when
        /// cursorShape is set to "vintage". Accepts values from 25-100.
        /// </summary>
        [JsonProperty("cursorHeight")]
        public long? CursorHeight { get; set; }

        /// <summary>
        /// Sets the cursor shape for the profile. Possible values: "vintage" ( ??? ), "bar" ( ???,
        /// default ), "underscore" ( ??? ), "filledBox" ( ??? ), "emptyBox" ( ??? )
        /// </summary>
        [JsonProperty("cursorShape", NullValueHandling = NullValueHandling.Ignore)]
        public CursorShape? CursorShape { get; set; }

        /// <summary>
        /// When set to true, enable retro terminal effects. This is an experimental feature, and its
        /// continued existence is not guaranteed.
        /// </summary>
        [JsonProperty("experimental.retroTerminalEffect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRetroTerminalEffect { get; set; }

        /// <summary>
        /// Name of the font face used in the profile.
        /// </summary>
        [JsonProperty("fontFace", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string FontFace { get; set; }

        /// <summary>
        /// Sets the font size.
        /// </summary>
        [JsonProperty("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public long? FontSize { get; set; }

        /// <summary>
        /// Sets the foreground color of the profile. Overrides foreground set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("foreground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Foreground { get; set; }

        /// <summary>
        /// If set to true, the profile will not appear in the list of profiles. This can be used to
        /// hide default profiles and dynamically generated profiles, while leaving them in your
        /// settings file.
        /// </summary>
        [JsonProperty("hidden", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        /// <summary>
        /// The number of lines above the ones displayed in the window you can scroll back to.
        /// </summary>
        [JsonProperty("historySize", NullValueHandling = NullValueHandling.Ignore)]
        public long? HistorySize { get; set; }

        /// <summary>
        /// Image file location of the icon used in the profile. Displays within the tab and the
        /// dropdown menu.
        /// </summary>
        [JsonProperty("icon")]
        [DefaultValue("")]         public string Icon { get; set; }

        /// <summary>
        /// Sets the padding around the text within the window. Can have three different formats: "#"
        /// sets the same padding for all sides, "#, #" sets the same padding for left-right and
        /// top-bottom, and "#, #, #, #" sets the padding individually for left, top, right, and
        /// bottom.
        /// </summary>
        [JsonProperty("padding", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Padding { get; set; }

        /// <summary>
        /// Defines the visibility of the scrollbar.
        /// </summary>
        [JsonProperty("scrollbarState", NullValueHandling = NullValueHandling.Ignore)]
        public ScrollbarState? ScrollbarState { get; set; }

        /// <summary>
        /// Sets the selection background color of the profile. Overrides selection background set in
        /// color scheme if colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("selectionBackground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string SelectionBackground { get; set; }

        /// <summary>
        /// When set to true, the window will scroll to the command input line when typing. When set
        /// to false, the window will not scroll when you start typing.
        /// </summary>
        [JsonProperty("snapOnInput", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapOnInput { get; set; }

        /// <summary>
        /// Stores the name of the profile generator that originated this profile.
        /// </summary>
        [JsonProperty("source")]
        [DefaultValue("")]         public string Source { get; set; }

        /// <summary>
        /// The directory the shell starts in when it is loaded.
        /// </summary>
        [JsonProperty("startingDirectory", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string StartingDirectory { get; set; }

        /// <summary>
        /// When set to true, tabTitle overrides the default title of the tab and any title change
        /// messages from the application will be suppressed. When set to false, tabTitle behaves as
        /// normal.
        /// </summary>
        [JsonProperty("suppressApplicationTitle", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressApplicationTitle { get; set; }

        /// <summary>
        /// If set, will replace the name as the title to pass to the shell on startup. Some shells
        /// (like bash) may choose to ignore this initial value, while others (cmd, powershell) may
        /// use this value over the lifetime of the application.
        /// </summary>
        [JsonProperty("tabTitle")]
        [DefaultValue("")]         public string TabTitle { get; set; }

        /// <summary>
        /// When set to true, the window will have an acrylic background. When set to false, the
        /// window will have a plain, untextured background.
        /// </summary>
        [JsonProperty("useAcrylic", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseAcrylic { get; set; }
    }

    /// <summary>
    /// Properties are specific to each color scheme. ColorTool is a great tool you can use to
    /// create and explore new color schemes. All colors use hex color format.
    /// </summary>
    public partial class SchemeList
    {
        /// <summary>
        /// Sets the background color of the color scheme.
        /// </summary>
        [JsonProperty("background", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Background { get; set; }

        /// <summary>
        /// Sets the color used as ANSI black.
        /// </summary>
        [JsonProperty("black", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Black { get; set; }

        /// <summary>
        /// Sets the color used as ANSI blue.
        /// </summary>
        [JsonProperty("blue", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Blue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright black.
        /// </summary>
        [JsonProperty("brightBlack", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightBlack { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright blue.
        /// </summary>
        [JsonProperty("brightBlue", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightBlue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright cyan.
        /// </summary>
        [JsonProperty("brightCyan", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightCyan { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright green.
        /// </summary>
        [JsonProperty("brightGreen", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightGreen { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright purple.
        /// </summary>
        [JsonProperty("brightPurple", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightPurple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright red.
        /// </summary>
        [JsonProperty("brightRed", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightRed { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright white.
        /// </summary>
        [JsonProperty("brightWhite", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightWhite { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright yellow.
        /// </summary>
        [JsonProperty("brightYellow", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string BrightYellow { get; set; }

        /// <summary>
        /// Sets the cursor color of the color scheme.
        /// </summary>
        [JsonProperty("cursorColor", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string CursorColor { get; set; }

        /// <summary>
        /// Sets the color used as ANSI cyan.
        /// </summary>
        [JsonProperty("cyan", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Cyan { get; set; }

        /// <summary>
        /// Sets the foreground color of the color scheme.
        /// </summary>
        [JsonProperty("foreground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Foreground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI green.
        /// </summary>
        [JsonProperty("green", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Green { get; set; }

        /// <summary>
        /// Name of the color scheme.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        [DefaultValue("")]         public string Name { get; set; }

        /// <summary>
        /// Sets the color used as ANSI purple.
        /// </summary>
        [JsonProperty("purple", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Purple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI red.
        /// </summary>
        [JsonProperty("red", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Red { get; set; }

        /// <summary>
        /// Sets the selection background color of the color scheme.
        /// </summary>
        [JsonProperty("selectionBackground", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string SelectionBackground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI white.
        /// </summary>
        [JsonProperty("white", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string White { get; set; }

        /// <summary>
        /// Sets the color used as ANSI yellow.
        /// </summary>
        [JsonProperty("yellow", NullValueHandling = NullValueHandling.Ignore)]
        [DefaultValue("")]         public string Yellow { get; set; }
    }

    public enum DynamicProfileSource { WindowsTerminalAzure, WindowsTerminalPowershellCore, WindowsTerminalWsl };

    /// <summary>
    /// The action to execute
    /// </summary>
    public enum CommandEnum { AdjustFontSize, ClosePane, CloseTab, CloseWindow, Copy, DecreaseFontSize, DuplicateTab, Find, MoveFocus, NewTab, NextTab, OpenNewTabDropdown, OpenSettings, Paste, PrevTab, ResetFontSize, ResizePane, ScrollDown, ScrollDownPage, ScrollUp, ScrollUpPage, SplitPane, SwitchToTab, ToggleFullscreen, Unbound };

    /// <summary>
    /// The action to execute
    /// </summary>
    public enum ActionEnum { AdjustFontSize, ClosePane, CloseTab, CloseWindow, Copy, DecreaseFontSize, DuplicateTab, Find, MoveFocus, NewTab, NextTab, OpenNewTabDropdown, OpenSettings, Paste, PrevTab, ResetFontSize, ResizePane, ScrollDown, ScrollDownPage, ScrollUp, ScrollUpPage, SplitPane, SwitchToTab, ToggleFullscreen, Unbound };

    /// <summary>
    /// The direction to move focus in, between panes
    ///
    /// The direction to move the pane separator in
    /// </summary>
    public enum Direction { Down, Left, Right, Up };

    /// <summary>
    /// The orientation to split the pane in, either vertical (think [|]), horizontal (think
    /// [-]), or auto (splits pane based on remaining space)
    /// </summary>
    public enum SplitState { Auto, Horizontal, Vertical };

    /// <summary>
    /// Defines whether the Terminal will launch as maximized or not.
    /// </summary>
    public enum LaunchMode { Default, Maximized };

    /// <summary>
    /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
    /// "cleartype" and "aliased". Note that changing this setting will require starting a new
    /// terminal instance.
    /// </summary>
    public enum AntialiasingMode { Aliased, Cleartype, Grayscale };

    /// <summary>
    /// Sets how the background image aligns to the boundaries of the window. Possible values:
    /// "center", "left", "top", "right", "bottom", "topLeft", "topRight", "bottomLeft",
    /// "bottomRight"
    /// </summary>
    public enum BackgroundImageAlignment { Bottom, BottomLeft, BottomRight, Center, Left, Right, Top, TopLeft, TopRight };

    /// <summary>
    /// Sets how the background image is resized to fill the window.
    /// </summary>
    public enum BackgroundImageStretchMode { Fill, None, Uniform, UniformToFill };

    public enum CloseOnExitEnum { Always, Graceful, Never };

    /// <summary>
    /// Sets the cursor shape for the profile. Possible values: "vintage" ( ??? ), "bar" ( ???,
    /// default ), "underscore" ( ??? ), "filledBox" ( ??? ), "emptyBox" ( ??? )
    /// </summary>
    public enum CursorShape { Bar, EmptyBox, FilledBox, Underscore, Vintage };

    /// <summary>
    /// Defines the visibility of the scrollbar.
    /// </summary>
    public enum ScrollbarState { Hidden, Visible };

    /// <summary>
    /// Sets the width of the tabs.
    /// </summary>
    public enum TabWidthMode { Equal, TitleLength };

    /// <summary>
    /// Sets the theme of the application.
    /// </summary>
    public enum Theme { Dark, Light, System };

    /// <summary>
    /// The action executed when the associated key bindings are pressed.
    /// </summary>
    public partial struct Command
    {
        public Action Action;
        public CommandEnum? Enum;

        public static implicit operator Command(Action Action) => new Command { Action = Action };
        public static implicit operator Command(CommandEnum Enum) => new Command { Enum = Enum };
        public bool IsNull => Action == null && Enum == null;
    }

    /// <summary>
    /// Defines the key combinations used to call the command.
    /// </summary>
    public partial struct Keys
    {
        public string String;
        public List<string> StringArray;

        public static implicit operator Keys(string String) => new Keys { String = String };
        public static implicit operator Keys(List<string> StringArray) => new Keys { StringArray = StringArray };
    }

    /// <summary>
    /// Sets how the profile reacts to termination or failure to launch. Possible values:
    /// "graceful" (close when exit is typed or the process exits normally), "always" (always
    /// close) and "never" (never close). true and false are accepted as synonyms for "graceful"
    /// and "never" respectively.
    /// </summary>
    public partial struct CloseOnExitUnion
    {
        public bool? Bool;
        public CloseOnExitEnum? Enum;

        public static implicit operator CloseOnExitUnion(bool Bool) => new CloseOnExitUnion { Bool = Bool };
        public static implicit operator CloseOnExitUnion(CloseOnExitEnum Enum) => new CloseOnExitUnion { Enum = Enum };
    }

    /// <summary>
    /// The number of rows to scroll at a time with the mouse wheel. This will override the
    /// system setting if the value is not zero or 'system'.
    /// </summary>
    public partial struct RowsToScroll
    {
        public long? Integer;
        public string String;

        public static implicit operator RowsToScroll(long Integer) => new RowsToScroll { Integer = Integer };
        public static implicit operator RowsToScroll(string String) => new RowsToScroll { String = String };
    }

    public partial class TerminalSettings
    {
        public static TerminalSettings FromJson(string json) => JsonConvert.DeserializeObject<TerminalSettings>(json, WindowsTerminal.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this TerminalSettings self) => JsonConvert.SerializeObject(self, WindowsTerminal.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            Formatting = Formatting.Indented,
            NullValueHandling = NullValueHandling.Ignore,
            DefaultValueHandling = DefaultValueHandling.Ignore,
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DynamicProfileSourceConverter.Singleton,
                CommandConverter.Singleton,
                ActionEnumConverter.Singleton,
                DirectionConverter.Singleton,
                SplitStateConverter.Singleton,
                CommandEnumConverter.Singleton,
                KeysConverter.Singleton,
                LaunchModeConverter.Singleton,
                AntialiasingModeConverter.Singleton,
                BackgroundImageAlignmentConverter.Singleton,
                BackgroundImageStretchModeConverter.Singleton,
                CloseOnExitUnionConverter.Singleton,
                CloseOnExitEnumConverter.Singleton,
                CursorShapeConverter.Singleton,
                ScrollbarStateConverter.Singleton,
                RowsToScrollConverter.Singleton,
                TabWidthModeConverter.Singleton,
                ThemeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DynamicProfileSourceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DynamicProfileSource) || t == typeof(DynamicProfileSource?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Windows.Terminal.Azure":
                    return DynamicProfileSource.WindowsTerminalAzure;
                case "Windows.Terminal.PowershellCore":
                    return DynamicProfileSource.WindowsTerminalPowershellCore;
                case "Windows.Terminal.Wsl":
                    return DynamicProfileSource.WindowsTerminalWsl;
            }
            throw new Exception("Cannot unmarshal type DynamicProfileSource");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DynamicProfileSource)untypedValue;
            switch (value)
            {
                case DynamicProfileSource.WindowsTerminalAzure:
                    serializer.Serialize(writer, "Windows.Terminal.Azure");
                    return;
                case DynamicProfileSource.WindowsTerminalPowershellCore:
                    serializer.Serialize(writer, "Windows.Terminal.PowershellCore");
                    return;
                case DynamicProfileSource.WindowsTerminalWsl:
                    serializer.Serialize(writer, "Windows.Terminal.Wsl");
                    return;
            }
            throw new Exception("Cannot marshal type DynamicProfileSource");
        }

        public static readonly DynamicProfileSourceConverter Singleton = new DynamicProfileSourceConverter();
    }

    internal class CommandConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Command) || t == typeof(Command?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Command { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "adjustFontSize":
                            return new Command { Enum = CommandEnum.AdjustFontSize };
                        case "closePane":
                            return new Command { Enum = CommandEnum.ClosePane };
                        case "closeTab":
                            return new Command { Enum = CommandEnum.CloseTab };
                        case "closeWindow":
                            return new Command { Enum = CommandEnum.CloseWindow };
                        case "copy":
                            return new Command { Enum = CommandEnum.Copy };
                        case "decreaseFontSize":
                            return new Command { Enum = CommandEnum.DecreaseFontSize };
                        case "duplicateTab":
                            return new Command { Enum = CommandEnum.DuplicateTab };
                        case "find":
                            return new Command { Enum = CommandEnum.Find };
                        case "moveFocus":
                            return new Command { Enum = CommandEnum.MoveFocus };
                        case "newTab":
                            return new Command { Enum = CommandEnum.NewTab };
                        case "nextTab":
                            return new Command { Enum = CommandEnum.NextTab };
                        case "openNewTabDropdown":
                            return new Command { Enum = CommandEnum.OpenNewTabDropdown };
                        case "openSettings":
                            return new Command { Enum = CommandEnum.OpenSettings };
                        case "paste":
                            return new Command { Enum = CommandEnum.Paste };
                        case "prevTab":
                            return new Command { Enum = CommandEnum.PrevTab };
                        case "resetFontSize":
                            return new Command { Enum = CommandEnum.ResetFontSize };
                        case "resizePane":
                            return new Command { Enum = CommandEnum.ResizePane };
                        case "scrollDown":
                            return new Command { Enum = CommandEnum.ScrollDown };
                        case "scrollDownPage":
                            return new Command { Enum = CommandEnum.ScrollDownPage };
                        case "scrollUp":
                            return new Command { Enum = CommandEnum.ScrollUp };
                        case "scrollUpPage":
                            return new Command { Enum = CommandEnum.ScrollUpPage };
                        case "splitPane":
                            return new Command { Enum = CommandEnum.SplitPane };
                        case "switchToTab":
                            return new Command { Enum = CommandEnum.SwitchToTab };
                        case "toggleFullscreen":
                            return new Command { Enum = CommandEnum.ToggleFullscreen };
                        case "unbound":
                            return new Command { Enum = CommandEnum.Unbound };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Action>(reader);
                    return new Command { Action = objectValue };
            }
            throw new Exception("Cannot unmarshal type Command");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Command)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case CommandEnum.AdjustFontSize:
                        serializer.Serialize(writer, "adjustFontSize");
                        return;
                    case CommandEnum.ClosePane:
                        serializer.Serialize(writer, "closePane");
                        return;
                    case CommandEnum.CloseTab:
                        serializer.Serialize(writer, "closeTab");
                        return;
                    case CommandEnum.CloseWindow:
                        serializer.Serialize(writer, "closeWindow");
                        return;
                    case CommandEnum.Copy:
                        serializer.Serialize(writer, "copy");
                        return;
                    case CommandEnum.DecreaseFontSize:
                        serializer.Serialize(writer, "decreaseFontSize");
                        return;
                    case CommandEnum.DuplicateTab:
                        serializer.Serialize(writer, "duplicateTab");
                        return;
                    case CommandEnum.Find:
                        serializer.Serialize(writer, "find");
                        return;
                    case CommandEnum.MoveFocus:
                        serializer.Serialize(writer, "moveFocus");
                        return;
                    case CommandEnum.NewTab:
                        serializer.Serialize(writer, "newTab");
                        return;
                    case CommandEnum.NextTab:
                        serializer.Serialize(writer, "nextTab");
                        return;
                    case CommandEnum.OpenNewTabDropdown:
                        serializer.Serialize(writer, "openNewTabDropdown");
                        return;
                    case CommandEnum.OpenSettings:
                        serializer.Serialize(writer, "openSettings");
                        return;
                    case CommandEnum.Paste:
                        serializer.Serialize(writer, "paste");
                        return;
                    case CommandEnum.PrevTab:
                        serializer.Serialize(writer, "prevTab");
                        return;
                    case CommandEnum.ResetFontSize:
                        serializer.Serialize(writer, "resetFontSize");
                        return;
                    case CommandEnum.ResizePane:
                        serializer.Serialize(writer, "resizePane");
                        return;
                    case CommandEnum.ScrollDown:
                        serializer.Serialize(writer, "scrollDown");
                        return;
                    case CommandEnum.ScrollDownPage:
                        serializer.Serialize(writer, "scrollDownPage");
                        return;
                    case CommandEnum.ScrollUp:
                        serializer.Serialize(writer, "scrollUp");
                        return;
                    case CommandEnum.ScrollUpPage:
                        serializer.Serialize(writer, "scrollUpPage");
                        return;
                    case CommandEnum.SplitPane:
                        serializer.Serialize(writer, "splitPane");
                        return;
                    case CommandEnum.SwitchToTab:
                        serializer.Serialize(writer, "switchToTab");
                        return;
                    case CommandEnum.ToggleFullscreen:
                        serializer.Serialize(writer, "toggleFullscreen");
                        return;
                    case CommandEnum.Unbound:
                        serializer.Serialize(writer, "unbound");
                        return;
                }
            }
            if (value.Action != null)
            {
                serializer.Serialize(writer, value.Action);
                return;
            }
            throw new Exception("Cannot marshal type Command");
        }

        public static readonly CommandConverter Singleton = new CommandConverter();
    }

    internal class ActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionEnum) || t == typeof(ActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "adjustFontSize":
                    return ActionEnum.AdjustFontSize;
                case "closePane":
                    return ActionEnum.ClosePane;
                case "closeTab":
                    return ActionEnum.CloseTab;
                case "closeWindow":
                    return ActionEnum.CloseWindow;
                case "copy":
                    return ActionEnum.Copy;
                case "decreaseFontSize":
                    return ActionEnum.DecreaseFontSize;
                case "duplicateTab":
                    return ActionEnum.DuplicateTab;
                case "find":
                    return ActionEnum.Find;
                case "moveFocus":
                    return ActionEnum.MoveFocus;
                case "newTab":
                    return ActionEnum.NewTab;
                case "nextTab":
                    return ActionEnum.NextTab;
                case "openNewTabDropdown":
                    return ActionEnum.OpenNewTabDropdown;
                case "openSettings":
                    return ActionEnum.OpenSettings;
                case "paste":
                    return ActionEnum.Paste;
                case "prevTab":
                    return ActionEnum.PrevTab;
                case "resetFontSize":
                    return ActionEnum.ResetFontSize;
                case "resizePane":
                    return ActionEnum.ResizePane;
                case "scrollDown":
                    return ActionEnum.ScrollDown;
                case "scrollDownPage":
                    return ActionEnum.ScrollDownPage;
                case "scrollUp":
                    return ActionEnum.ScrollUp;
                case "scrollUpPage":
                    return ActionEnum.ScrollUpPage;
                case "splitPane":
                    return ActionEnum.SplitPane;
                case "switchToTab":
                    return ActionEnum.SwitchToTab;
                case "toggleFullscreen":
                    return ActionEnum.ToggleFullscreen;
                case "unbound":
                    return ActionEnum.Unbound;
            }
            throw new Exception("Cannot unmarshal type ActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ActionEnum)untypedValue;
            switch (value)
            {
                case ActionEnum.AdjustFontSize:
                    serializer.Serialize(writer, "adjustFontSize");
                    return;
                case ActionEnum.ClosePane:
                    serializer.Serialize(writer, "closePane");
                    return;
                case ActionEnum.CloseTab:
                    serializer.Serialize(writer, "closeTab");
                    return;
                case ActionEnum.CloseWindow:
                    serializer.Serialize(writer, "closeWindow");
                    return;
                case ActionEnum.Copy:
                    serializer.Serialize(writer, "copy");
                    return;
                case ActionEnum.DecreaseFontSize:
                    serializer.Serialize(writer, "decreaseFontSize");
                    return;
                case ActionEnum.DuplicateTab:
                    serializer.Serialize(writer, "duplicateTab");
                    return;
                case ActionEnum.Find:
                    serializer.Serialize(writer, "find");
                    return;
                case ActionEnum.MoveFocus:
                    serializer.Serialize(writer, "moveFocus");
                    return;
                case ActionEnum.NewTab:
                    serializer.Serialize(writer, "newTab");
                    return;
                case ActionEnum.NextTab:
                    serializer.Serialize(writer, "nextTab");
                    return;
                case ActionEnum.OpenNewTabDropdown:
                    serializer.Serialize(writer, "openNewTabDropdown");
                    return;
                case ActionEnum.OpenSettings:
                    serializer.Serialize(writer, "openSettings");
                    return;
                case ActionEnum.Paste:
                    serializer.Serialize(writer, "paste");
                    return;
                case ActionEnum.PrevTab:
                    serializer.Serialize(writer, "prevTab");
                    return;
                case ActionEnum.ResetFontSize:
                    serializer.Serialize(writer, "resetFontSize");
                    return;
                case ActionEnum.ResizePane:
                    serializer.Serialize(writer, "resizePane");
                    return;
                case ActionEnum.ScrollDown:
                    serializer.Serialize(writer, "scrollDown");
                    return;
                case ActionEnum.ScrollDownPage:
                    serializer.Serialize(writer, "scrollDownPage");
                    return;
                case ActionEnum.ScrollUp:
                    serializer.Serialize(writer, "scrollUp");
                    return;
                case ActionEnum.ScrollUpPage:
                    serializer.Serialize(writer, "scrollUpPage");
                    return;
                case ActionEnum.SplitPane:
                    serializer.Serialize(writer, "splitPane");
                    return;
                case ActionEnum.SwitchToTab:
                    serializer.Serialize(writer, "switchToTab");
                    return;
                case ActionEnum.ToggleFullscreen:
                    serializer.Serialize(writer, "toggleFullscreen");
                    return;
                case ActionEnum.Unbound:
                    serializer.Serialize(writer, "unbound");
                    return;
            }
            throw new Exception("Cannot marshal type ActionEnum");
        }

        public static readonly ActionEnumConverter Singleton = new ActionEnumConverter();
    }

    internal class DirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Direction) || t == typeof(Direction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "down":
                    return Direction.Down;
                case "left":
                    return Direction.Left;
                case "right":
                    return Direction.Right;
                case "up":
                    return Direction.Up;
            }
            throw new Exception("Cannot unmarshal type Direction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Direction)untypedValue;
            switch (value)
            {
                case Direction.Down:
                    serializer.Serialize(writer, "down");
                    return;
                case Direction.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case Direction.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case Direction.Up:
                    serializer.Serialize(writer, "up");
                    return;
            }
            throw new Exception("Cannot marshal type Direction");
        }

        public static readonly DirectionConverter Singleton = new DirectionConverter();
    }

    internal class SplitStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SplitState) || t == typeof(SplitState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "auto":
                    return SplitState.Auto;
                case "horizontal":
                    return SplitState.Horizontal;
                case "vertical":
                    return SplitState.Vertical;
            }
            throw new Exception("Cannot unmarshal type SplitState");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SplitState)untypedValue;
            switch (value)
            {
                case SplitState.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case SplitState.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case SplitState.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type SplitState");
        }

        public static readonly SplitStateConverter Singleton = new SplitStateConverter();
    }

    internal class CommandEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CommandEnum) || t == typeof(CommandEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "adjustFontSize":
                    return CommandEnum.AdjustFontSize;
                case "closePane":
                    return CommandEnum.ClosePane;
                case "closeTab":
                    return CommandEnum.CloseTab;
                case "closeWindow":
                    return CommandEnum.CloseWindow;
                case "copy":
                    return CommandEnum.Copy;
                case "decreaseFontSize":
                    return CommandEnum.DecreaseFontSize;
                case "duplicateTab":
                    return CommandEnum.DuplicateTab;
                case "find":
                    return CommandEnum.Find;
                case "moveFocus":
                    return CommandEnum.MoveFocus;
                case "newTab":
                    return CommandEnum.NewTab;
                case "nextTab":
                    return CommandEnum.NextTab;
                case "openNewTabDropdown":
                    return CommandEnum.OpenNewTabDropdown;
                case "openSettings":
                    return CommandEnum.OpenSettings;
                case "paste":
                    return CommandEnum.Paste;
                case "prevTab":
                    return CommandEnum.PrevTab;
                case "resetFontSize":
                    return CommandEnum.ResetFontSize;
                case "resizePane":
                    return CommandEnum.ResizePane;
                case "scrollDown":
                    return CommandEnum.ScrollDown;
                case "scrollDownPage":
                    return CommandEnum.ScrollDownPage;
                case "scrollUp":
                    return CommandEnum.ScrollUp;
                case "scrollUpPage":
                    return CommandEnum.ScrollUpPage;
                case "splitPane":
                    return CommandEnum.SplitPane;
                case "switchToTab":
                    return CommandEnum.SwitchToTab;
                case "toggleFullscreen":
                    return CommandEnum.ToggleFullscreen;
                case "unbound":
                    return CommandEnum.Unbound;
            }
            throw new Exception("Cannot unmarshal type CommandEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CommandEnum)untypedValue;
            switch (value)
            {
                case CommandEnum.AdjustFontSize:
                    serializer.Serialize(writer, "adjustFontSize");
                    return;
                case CommandEnum.ClosePane:
                    serializer.Serialize(writer, "closePane");
                    return;
                case CommandEnum.CloseTab:
                    serializer.Serialize(writer, "closeTab");
                    return;
                case CommandEnum.CloseWindow:
                    serializer.Serialize(writer, "closeWindow");
                    return;
                case CommandEnum.Copy:
                    serializer.Serialize(writer, "copy");
                    return;
                case CommandEnum.DecreaseFontSize:
                    serializer.Serialize(writer, "decreaseFontSize");
                    return;
                case CommandEnum.DuplicateTab:
                    serializer.Serialize(writer, "duplicateTab");
                    return;
                case CommandEnum.Find:
                    serializer.Serialize(writer, "find");
                    return;
                case CommandEnum.MoveFocus:
                    serializer.Serialize(writer, "moveFocus");
                    return;
                case CommandEnum.NewTab:
                    serializer.Serialize(writer, "newTab");
                    return;
                case CommandEnum.NextTab:
                    serializer.Serialize(writer, "nextTab");
                    return;
                case CommandEnum.OpenNewTabDropdown:
                    serializer.Serialize(writer, "openNewTabDropdown");
                    return;
                case CommandEnum.OpenSettings:
                    serializer.Serialize(writer, "openSettings");
                    return;
                case CommandEnum.Paste:
                    serializer.Serialize(writer, "paste");
                    return;
                case CommandEnum.PrevTab:
                    serializer.Serialize(writer, "prevTab");
                    return;
                case CommandEnum.ResetFontSize:
                    serializer.Serialize(writer, "resetFontSize");
                    return;
                case CommandEnum.ResizePane:
                    serializer.Serialize(writer, "resizePane");
                    return;
                case CommandEnum.ScrollDown:
                    serializer.Serialize(writer, "scrollDown");
                    return;
                case CommandEnum.ScrollDownPage:
                    serializer.Serialize(writer, "scrollDownPage");
                    return;
                case CommandEnum.ScrollUp:
                    serializer.Serialize(writer, "scrollUp");
                    return;
                case CommandEnum.ScrollUpPage:
                    serializer.Serialize(writer, "scrollUpPage");
                    return;
                case CommandEnum.SplitPane:
                    serializer.Serialize(writer, "splitPane");
                    return;
                case CommandEnum.SwitchToTab:
                    serializer.Serialize(writer, "switchToTab");
                    return;
                case CommandEnum.ToggleFullscreen:
                    serializer.Serialize(writer, "toggleFullscreen");
                    return;
                case CommandEnum.Unbound:
                    serializer.Serialize(writer, "unbound");
                    return;
            }
            throw new Exception("Cannot marshal type CommandEnum");
        }

        public static readonly CommandEnumConverter Singleton = new CommandEnumConverter();
    }

    internal class KeysConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Keys) || t == typeof(Keys?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Keys { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<string>>(reader);
                    return new Keys { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Keys");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Keys)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Keys");
        }

        public static readonly KeysConverter Singleton = new KeysConverter();
    }

    internal class LaunchModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LaunchMode) || t == typeof(LaunchMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "default":
                    return LaunchMode.Default;
                case "maximized":
                    return LaunchMode.Maximized;
            }
            throw new Exception("Cannot unmarshal type LaunchMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LaunchMode)untypedValue;
            switch (value)
            {
                case LaunchMode.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case LaunchMode.Maximized:
                    serializer.Serialize(writer, "maximized");
                    return;
            }
            throw new Exception("Cannot marshal type LaunchMode");
        }

        public static readonly LaunchModeConverter Singleton = new LaunchModeConverter();
    }

    internal class MinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(decimal) || t == typeof(decimal?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<decimal>(reader);
            if (value >= 0 && value <= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type decimal");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (decimal)untypedValue;
            if (value >= 0 && value <= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type decimal");
        }

        public static readonly MinMaxValueCheckConverter Singleton = new MinMaxValueCheckConverter();
    }

    internal class AntialiasingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AntialiasingMode) || t == typeof(AntialiasingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "aliased":
                    return AntialiasingMode.Aliased;
                case "cleartype":
                    return AntialiasingMode.Cleartype;
                case "grayscale":
                    return AntialiasingMode.Grayscale;
            }
            throw new Exception("Cannot unmarshal type AntialiasingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AntialiasingMode)untypedValue;
            switch (value)
            {
                case AntialiasingMode.Aliased:
                    serializer.Serialize(writer, "aliased");
                    return;
                case AntialiasingMode.Cleartype:
                    serializer.Serialize(writer, "cleartype");
                    return;
                case AntialiasingMode.Grayscale:
                    serializer.Serialize(writer, "grayscale");
                    return;
            }
            throw new Exception("Cannot marshal type AntialiasingMode");
        }

        public static readonly AntialiasingModeConverter Singleton = new AntialiasingModeConverter();
    }

    internal class BackgroundImageAlignmentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BackgroundImageAlignment) || t == typeof(BackgroundImageAlignment?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return BackgroundImageAlignment.Bottom;
                case "bottomLeft":
                    return BackgroundImageAlignment.BottomLeft;
                case "bottomRight":
                    return BackgroundImageAlignment.BottomRight;
                case "center":
                    return BackgroundImageAlignment.Center;
                case "left":
                    return BackgroundImageAlignment.Left;
                case "right":
                    return BackgroundImageAlignment.Right;
                case "top":
                    return BackgroundImageAlignment.Top;
                case "topLeft":
                    return BackgroundImageAlignment.TopLeft;
                case "topRight":
                    return BackgroundImageAlignment.TopRight;
            }
            throw new Exception("Cannot unmarshal type BackgroundImageAlignment");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BackgroundImageAlignment)untypedValue;
            switch (value)
            {
                case BackgroundImageAlignment.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case BackgroundImageAlignment.BottomLeft:
                    serializer.Serialize(writer, "bottomLeft");
                    return;
                case BackgroundImageAlignment.BottomRight:
                    serializer.Serialize(writer, "bottomRight");
                    return;
                case BackgroundImageAlignment.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case BackgroundImageAlignment.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case BackgroundImageAlignment.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case BackgroundImageAlignment.Top:
                    serializer.Serialize(writer, "top");
                    return;
                case BackgroundImageAlignment.TopLeft:
                    serializer.Serialize(writer, "topLeft");
                    return;
                case BackgroundImageAlignment.TopRight:
                    serializer.Serialize(writer, "topRight");
                    return;
            }
            throw new Exception("Cannot marshal type BackgroundImageAlignment");
        }

        public static readonly BackgroundImageAlignmentConverter Singleton = new BackgroundImageAlignmentConverter();
    }

    internal class BackgroundImageStretchModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BackgroundImageStretchMode) || t == typeof(BackgroundImageStretchMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "fill":
                    return BackgroundImageStretchMode.Fill;
                case "none":
                    return BackgroundImageStretchMode.None;
                case "uniform":
                    return BackgroundImageStretchMode.Uniform;
                case "uniformToFill":
                    return BackgroundImageStretchMode.UniformToFill;
            }
            throw new Exception("Cannot unmarshal type BackgroundImageStretchMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BackgroundImageStretchMode)untypedValue;
            switch (value)
            {
                case BackgroundImageStretchMode.Fill:
                    serializer.Serialize(writer, "fill");
                    return;
                case BackgroundImageStretchMode.None:
                    serializer.Serialize(writer, "none");
                    return;
                case BackgroundImageStretchMode.Uniform:
                    serializer.Serialize(writer, "uniform");
                    return;
                case BackgroundImageStretchMode.UniformToFill:
                    serializer.Serialize(writer, "uniformToFill");
                    return;
            }
            throw new Exception("Cannot marshal type BackgroundImageStretchMode");
        }

        public static readonly BackgroundImageStretchModeConverter Singleton = new BackgroundImageStretchModeConverter();
    }

    internal class CloseOnExitUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CloseOnExitUnion) || t == typeof(CloseOnExitUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new CloseOnExitUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "always":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Always };
                        case "graceful":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Graceful };
                        case "never":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Never };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type CloseOnExitUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CloseOnExitUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case CloseOnExitEnum.Always:
                        serializer.Serialize(writer, "always");
                        return;
                    case CloseOnExitEnum.Graceful:
                        serializer.Serialize(writer, "graceful");
                        return;
                    case CloseOnExitEnum.Never:
                        serializer.Serialize(writer, "never");
                        return;
                }
            }
            throw new Exception("Cannot marshal type CloseOnExitUnion");
        }

        public static readonly CloseOnExitUnionConverter Singleton = new CloseOnExitUnionConverter();
    }

    internal class CloseOnExitEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CloseOnExitEnum) || t == typeof(CloseOnExitEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "always":
                    return CloseOnExitEnum.Always;
                case "graceful":
                    return CloseOnExitEnum.Graceful;
                case "never":
                    return CloseOnExitEnum.Never;
            }
            throw new Exception("Cannot unmarshal type CloseOnExitEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CloseOnExitEnum)untypedValue;
            switch (value)
            {
                case CloseOnExitEnum.Always:
                    serializer.Serialize(writer, "always");
                    return;
                case CloseOnExitEnum.Graceful:
                    serializer.Serialize(writer, "graceful");
                    return;
                case CloseOnExitEnum.Never:
                    serializer.Serialize(writer, "never");
                    return;
            }
            throw new Exception("Cannot marshal type CloseOnExitEnum");
        }

        public static readonly CloseOnExitEnumConverter Singleton = new CloseOnExitEnumConverter();
    }

    internal class CursorShapeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CursorShape) || t == typeof(CursorShape?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bar":
                    return CursorShape.Bar;
                case "emptyBox":
                    return CursorShape.EmptyBox;
                case "filledBox":
                    return CursorShape.FilledBox;
                case "underscore":
                    return CursorShape.Underscore;
                case "vintage":
                    return CursorShape.Vintage;
            }
            throw new Exception("Cannot unmarshal type CursorShape");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CursorShape)untypedValue;
            switch (value)
            {
                case CursorShape.Bar:
                    serializer.Serialize(writer, "bar");
                    return;
                case CursorShape.EmptyBox:
                    serializer.Serialize(writer, "emptyBox");
                    return;
                case CursorShape.FilledBox:
                    serializer.Serialize(writer, "filledBox");
                    return;
                case CursorShape.Underscore:
                    serializer.Serialize(writer, "underscore");
                    return;
                case CursorShape.Vintage:
                    serializer.Serialize(writer, "vintage");
                    return;
            }
            throw new Exception("Cannot marshal type CursorShape");
        }

        public static readonly CursorShapeConverter Singleton = new CursorShapeConverter();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }

    internal class ScrollbarStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScrollbarState) || t == typeof(ScrollbarState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hidden":
                    return ScrollbarState.Hidden;
                case "visible":
                    return ScrollbarState.Visible;
            }
            throw new Exception("Cannot unmarshal type ScrollbarState");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScrollbarState)untypedValue;
            switch (value)
            {
                case ScrollbarState.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
                case ScrollbarState.Visible:
                    serializer.Serialize(writer, "visible");
                    return;
            }
            throw new Exception("Cannot marshal type ScrollbarState");
        }

        public static readonly ScrollbarStateConverter Singleton = new ScrollbarStateConverter();
    }

    internal class RowsToScrollConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RowsToScroll) || t == typeof(RowsToScroll?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new RowsToScroll { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new RowsToScroll { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type RowsToScroll");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RowsToScroll)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type RowsToScroll");
        }

        public static readonly RowsToScrollConverter Singleton = new RowsToScrollConverter();
    }

    internal class TabWidthModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TabWidthMode) || t == typeof(TabWidthMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "equal":
                    return TabWidthMode.Equal;
                case "titleLength":
                    return TabWidthMode.TitleLength;
            }
            throw new Exception("Cannot unmarshal type TabWidthMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TabWidthMode)untypedValue;
            switch (value)
            {
                case TabWidthMode.Equal:
                    serializer.Serialize(writer, "equal");
                    return;
                case TabWidthMode.TitleLength:
                    serializer.Serialize(writer, "titleLength");
                    return;
            }
            throw new Exception("Cannot marshal type TabWidthMode");
        }

        public static readonly TabWidthModeConverter Singleton = new TabWidthModeConverter();
    }

    internal class ThemeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Theme) || t == typeof(Theme?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "dark":
                    return Theme.Dark;
                case "light":
                    return Theme.Light;
                case "system":
                    return Theme.System;
            }
            throw new Exception("Cannot unmarshal type Theme");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Theme)untypedValue;
            switch (value)
            {
                case Theme.Dark:
                    serializer.Serialize(writer, "dark");
                    return;
                case Theme.Light:
                    serializer.Serialize(writer, "light");
                    return;
                case Theme.System:
                    serializer.Serialize(writer, "system");
                    return;
            }
            throw new Exception("Cannot marshal type Theme");
        }

        public static readonly ThemeConverter Singleton = new ThemeConverter();
    }
}

